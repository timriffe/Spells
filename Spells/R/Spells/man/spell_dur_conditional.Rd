% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Counting.R
\name{spell_dur_conditional}
\alias{spell_dur_conditional}
\title{impute conditional durations of episodes in specified reference state}
\usage{
spell_dur_conditional(x, state = "Inactive", entry = TRUE,
  step_size = 1)
}
\arguments{
\item{x}{character vector of state in each time step}

\item{state}{character. The reference state. Could be a vector of states too.}

\item{entry}{logical. Do we impute the episode duration at the point of entry or exit?}

\item{step_size}{numeric. Default \code{1}. What is the time interval for the discrete bins in \code{x}.}
}
\description{
produce a vector of \code{length(x)} values corresponding to the total duration of each episode of the reference state in either the entry time step or the exit time step
}
\details{
\code{NA} are given for other states. \code{state} can be a vector of states if you'd rather consider certain states merged into single episodes.
}
\examples{
x <- rep(c("Employed", "Inactive", "Retired", "Employed", "Retired", 
           "Dead"), c(7,  8,  3,  3, 25,  5))
# a single 8-year spell of inactivity, conditional on entry
spell_dur_conditional(x, "Inactive", entry = TRUE)
# a single 8-year spell of inactivity, conditional on exit
spell_dur_conditional(x, "Inactive", entry = FALSE)

# merges first consecutive employment and inactivity spells into a single spell,
# also catches second employment after retirement
spell_dur_conditional(x, state=c("Inactive","Employed"), entry = TRUE)
spell_dur_conditional(x, state=c("Inactive","Employed"), entry = FALSE)
}
